# Code Retreat 20240126

Use ChatGPT to generate Game of Life.

## GPT4

```
在一个不限大小的 2 维平面上的网格上，每个格子有 2 个状态：
活（用 O 表示）
死（用 X 表示）
所有格子的默认状态是 X（死掉）
所有格子的状态按以下规则进行更新，每一轮只考虑目前这一轮的格子状态：
1. 对一个 O 格子，如果其周围邻居有 < 2 个 O 格子，下一轮这个格子变为 X（死掉）
2. 对一个 O 格子，如果其周围邻居有 2/3 个 O 格子，下一轮这个格子仍为 O（活着）
3. 对一个 O 格子，如果其周围邻居有 > 3 个 O 格子，下一轮这个格子变为 X（死掉）
4. 对一个 X 格子，如果其周围邻居有 3 个 O 格子，下一轮这个格子变为 O（活着）
邻居是指格子周围直接相邻的 8 个（包括上、下、左、右、及4个对角线方向的格子）

实现以下的 golang 函数
func next(board ...) board ... {
    // 返回下一轮游戏的状态
}
```

以上提示词生成的代码有一处 bug

```
    for p, alive := range currentBoard {
        aliveNeighbors := countAliveNeighbors(currentBoard, p)
        // 应用生命游戏的规则

代码只检查了 currentBoard 内的 Point，应该还要检查 currentBoard
内的 Point 的邻居细胞的状态；生成一段新的代码来遍历 currentBoard 内的 Point
和他们的邻居细胞
```

```
写一段代码将 Board 初始化为有一行 3 个或者的细胞
```

## 其他大模型

其他大模型与 GPT4 差距明显

GPT3.5 无法生成可用代码

GLM4、文心一言生成可用代码，但不理解“不限大小”，从而选择的设计都基于固定大小的
盘面，因此无法满足题目的需求；

```
在一个不限大小的 2 维平面上的网格上，每个格子有 2 个状态：
```

## 测试

测试代码生成异常容易，所有大模型均完整生成可用的测试，并运行通过。
